{
  "hash": "135f8eccae3dac54a71c2cc57421539c",
  "result": {
    "markdown": "# Answers for @sec-joinex {#sec-appendixjoinex}\n\nThe following are answers to the exercises in @sec-joinex.\n\n1.  Assign the built-in dataframe `Orange` to an object named whatever you want. This dataframe relates to the age and circumference of orange trees. First, with respect to the specific tree, is the dataframe in long or wide format? Please explain your answer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree <- Orange\n\nhead(tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Tree  age circumference\n1    1  118            30\n2    1  484            58\n3    1  664            87\n4    1 1004           115\n5    1 1231           120\n6    1 1372           142\n```\n:::\n\n```{.r .cell-code}\n# The dataframe appears to be in long format, as each tree has multiple rows.\n```\n:::\n\n\n2.  Once again with respect to individual trees, reshape the dataframe. If you believe it is in long format, reshape to wide (hint: this is the correct answer). Assign the reshaped dataframe to a new object with a name that indicates the reshaped nature of the data (e.g., \"tree_wide\"). What you want to see is a dataframe where each row corresponds to age, and separate columns listing the circumference of each tree. Use an approach you have seen to name each column \"Tree (number) circumference\". For example, the first tree column should be named \"Tree 1 circumference\", the second should be called \"Tree 2 circumference\", and so on. Once you have finished, use the `head()` function to show the first five rows of the reshaped dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ntree_wide <- tree %>%\n   pivot_wider(\n    names_from = Tree,\n    values_from = circumference,\n    names_glue = \"Tree {Tree} {.value}\"\n    )\n\nhead(tree_wide, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n    age `Tree 1 circumference` `Tree 2 circumference` `Tree 3 circumference`\n  <dbl>                  <dbl>                  <dbl>                  <dbl>\n1   118                     30                     33                     30\n2   484                     58                     69                     51\n3   664                     87                    111                     75\n4  1004                    115                    156                    108\n5  1231                    120                    172                    115\n# ℹ 2 more variables: `Tree 4 circumference` <dbl>,\n#   `Tree 5 circumference` <dbl>\n```\n:::\n:::\n\n\n3.  Let's go backwards. Take the wide dataframe from Question 2, and reshape into long format, assigning this to a new object with a name noting that the new dataframe is in long format (e.g. \"tree_long\"). Here, we want each row to correspond to a tree, and separate columns for age and circumference, labelled as such. Then, use a command that you've seen before to make the new tree column come first in order in the dataframe. Finally, use the `head()` to show the first five rows of the new dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_long <- tree_wide %>%\n  pivot_longer(\n    cols = c(\"Tree 1 circumference\", \n             \"Tree 2 circumference\", \n             \"Tree 3 circumference\",\n             \"Tree 4 circumference\",\n             \"Tree 5 circumference\"),\n    names_to = \"Tree\",\n    names_pattern = \"[^Tree](.)\",   ## This is basically saying take the former column labels (Tree 1 circumference, Tree 2 circumference, etc.), exclude the word Tree [^Tree], and keep the first character after the word 'Tree', and nothing else.\n    values_to = \"Circumference\"\n    ) %>%\n  relocate(Tree, .before = everything()  ## This puts the Tree column first in order.\n           )\n\nhead(tree_long, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  Tree    age Circumference\n  <chr> <dbl>         <dbl>\n1 1       118            30\n2 2       118            33\n3 3       118            30\n4 4       118            32\n5 5       118            30\n```\n:::\n:::\n\n\n4.  Let's go back to the original `Orange` dataframe, or the object to which you initially assigned it. Next, we're going to create two new dataframes `tree2` and `tree3` using the code below. We're also going to create an ID variable for the two dataframes with the same rows in order to have unique indices for each row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree <- Orange\n\nnewage <- tree$circumference/2.5\ntreeid <- tree$Tree\n\ntree2 <- data.frame(Tree = treeid,\n                    \"Age_years\" = newage)\n\n\ntree3 <- data.frame(Tree = c(rep(6, 7)),\n                    \"Age_years\" = c(10.4, \n                                      21.2, \n                                      30.4, \n                                      41.3, \n                                      55.8, \n                                      66.7,\n                                      71.4),\n                    ID = c(seq(from = 36, to = 42)\n                           )\n                    )\ntree3$Tree <- ordered(tree3$Tree) ## This will make the Tree column in tree3 the same class as the Tree column in the original dataframe. This is needed for merging.\n\n## This creates an ID variable in the original dataframe and in tree2.\ntree$ID <- 1:nrow(tree)\ntree2$ID <- 1:nrow(tree2)\n```\n:::\n\n\n5.  Create a new dataframe `tree4` that merges `tree2` with the `Orange` dataframe or whatever object you assigned it to. Note, what we want here is to add a new column `Age (Years)` to the same rows or observational units. The `ID` variable we created above should be used to link the dataframes. Once the merge is complete, print the first six rows of the merged dataframe to make sure it worked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree4 <- tree %>%\n  left_join(tree2,\n            by = c(\"ID\" = \"ID\")\n            )\n\nhead(tree4, n = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Tree.x  age circumference ID Tree.y Age_years\n1      1  118            30  1      1      12.0\n2      1  484            58  2      1      23.2\n3      1  664            87  3      1      34.8\n4      1 1004           115  4      1      46.0\n5      1 1231           120  5      1      48.0\n6      1 1372           142  6      1      56.8\n```\n:::\n\n```{.r .cell-code}\n# While this is fine and links the data well, we do have duplicate Tree columns. Since the two dataframes are arranged in the same order (i.e. the ID variables are both sequentially sorted in each dataframe), we can also use the simpler cbind() function. This code takes the unique column from tree2 and binds it to the tree dataframe.\n\ntree4 <- cbind(tree, tree2$Age_years)\n\n## Let's move ID to the front and clean up the Age_years variable name.\n\ntree4 <- tree4 %>%\n  relocate(ID, .before = everything()) %>%\n  rename(\"Age (years)\" = `tree2$Age_years`)\n\nhead(tree4, n = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Tree  age circumference Age (years)\n1  1    1  118            30        12.0\n2  2    1  484            58        23.2\n3  3    1  664            87        34.8\n4  4    1 1004           115        46.0\n5  5    1 1231           120        48.0\n6  6    1 1372           142        56.8\n```\n:::\n:::\n\n\n6.  Now create a new dataframe `tree5` which appends rows from `tree3` to the `tree2` dataframe we created in Question 2. Once the merge is complete, print the *last* seven rows of the merged dataframe to make sure it worked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree5 <- rbind(tree2, tree3)\n\ntail(tree5, n = 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Tree Age_years ID\n36    6      10.4 36\n37    6      21.2 37\n38    6      30.4 38\n39    6      41.3 39\n40    6      55.8 40\n41    6      66.7 41\n42    6      71.4 42\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}