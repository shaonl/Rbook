{
  "hash": "eb50499811b8de200a13051d1d6d9b9c",
  "result": {
    "markdown": "# Strings & Comparisons {#sec-ops}\n\n## Strings\n\n![](/Images/strings.png)\n\nAs we discussed in @sec-dts, character values are stored in objects known as *strings* in R. Let's go over a few key things with strings.\n\nFirst, let's remember that string values are surrounded by quotes, such as `x <- \"Hello, World\"`. These can also be single quotes, such as `y <- 'Hello, World'.` However, you CANNOT combine double quotes on one end of the value and single quotes on the other, such as `z <- 'Hello, World\"`. So, make sure you are consistent. I recommend using double quotes consistently, as R will always print and store the value with double quotes, even if you store the variable using single quotes.\n\nWhat if you want to store quote within a quote? In this case, you can use the standard grammar rules of American English. According to [Brittney Ross from *grammarly*](https://www.grammarly.com/blog/quotation-within-quotation/#:~:text=In%20American%20English%2C%20use%20double,marks%20for%20quotations%20within%20quotations.), in American English, we use double quotation marks for quotes, and single quotation marks for quotes within quotes. Here's an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- \"Invoking the Bard, she replied 'To thine own self be true.'\"\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Invoking the Bard, she replied 'To thine own self be true.'\"\n```\n:::\n:::\n\n\nNotice that simply running the object name returns its value, in the same way that `print()`does. We can check the length of a string with the `nchar()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 59\n```\n:::\n:::\n\n\nWe can also check if a character or sequence of characters exist in a given string using the `grepl()` function, in which the first argument is the character/sequence of interest, and the second argument is the string. Evaluating this expression returns a logical value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\"Bard\", a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl(\"Z\", a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nTo combine strings, we can use the `paste()` function, where the arguments are the string objects to be combined. This is also called *concatenating* or *merging* multiple strings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's create two new string objects b and c.\n\nb <- \"Demurely and without hesitation, I invoked Jonson 'There is no greater hell than to be a prisoner of fear.'\"\n\nc <- \"That ended the conversation rather quickly.\"\n\n# Now we combine the three\n\nd <- paste(a,b,c)\n\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Invoking the Bard, she replied 'To thine own self be true.' Demurely and without hesitation, I invoked Jonson 'There is no greater hell than to be a prisoner of fear.' That ended the conversation rather quickly.\"\n```\n:::\n:::\n\n\nNote that the `paste()` function concatenates strings with a space by default. If we don't want spaces by default, we can use the `paste0()` function which does not separate strings by spaces, by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(\"Remove\", \"All\", \"Spaces\", \"Now\", \"!\", \"!\", \"!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"RemoveAllSpacesNow!!!\"\n```\n:::\n:::\n\n\nThe `stringr` package also has a number of useful functions for manipulating strings. One thing I find especially helpful in this package is the ability to convert the characters in a string to lowercase, uppercase, or title case. This is especially helpful if you have values with inconsistent punctuation. Here's an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A string with inconsistent punctuation\nlibrary(stringr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'stringr' was built under R version 4.2.2\n```\n:::\n\n```{.r .cell-code}\ne <- \"WOW, tHiS Is qUiTE a mESsY oNe.\"\n\n# Let's str_to_lower() function to make all characters lowercase.\n\nf <- str_to_lower(e)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wow, this is quite a messy one.\"\n```\n:::\n\n```{.r .cell-code}\n# Now we use the str_to_upper() function to make all characters uppercase. \n\ng <- str_to_upper(f)\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"WOW, THIS IS QUITE A MESSY ONE.\"\n```\n:::\n\n```{.r .cell-code}\n# Finally, we use the str_to_title() function to make all characters title case.\n\nh <- str_to_title(g)\nh\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Wow, This Is Quite A Messy One.\"\n```\n:::\n:::\n\n\nSometimes you have a string or vector of strings for which you want to apply a broad-sweeping change. This commonly happens with variable names or values, and sometimes, you want to write code to make changes to a number of values without changing the values one-by-one. In this case, the `sub()` and `gsub()` functions are very useful. These functions take the first argument as the pattern to match, the second as the thing you want to replace the pattern with, and the third is the dataframe or vector you are modifying. The main difference between `sub()` and `gsub()` is that `sub()` only modifies the first match in an individual string or vector, whereas `gsub()` modifies all matches in a particular string or vector. I tend to use `gsub()` more often than `sub()`, but use what works for you. Let's see how it works.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First let's create a vector of strings.\n\nintro <- c(\"Hello, my name is Jamal.\")\nprint(intro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello, my name is Jamal.\"\n```\n:::\n\n```{.r .cell-code}\n# Let's say I want to substitute another name for Jamal here. The gsub() function helps me do that. \n\ngsub('Jamal', \"Monica\", intro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello, my name is Monica.\"\n```\n:::\n\n```{.r .cell-code}\n# If you want to add a prefix to a vector of strings based on a particular pattern, you can use the weird symbol combination .*^ (period asterisk caret) as the first argument.\n\ngsub(\".*^\", \"Welcome and \", intro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Welcome and Hello, my name is Jamal.\"\n```\n:::\n\n```{.r .cell-code}\n# Finally, let's work with a dataframe.\n\ndf <- data.frame(id = 1:4,\n                     gender = c(\"male\", \"female\", \"transgender\", \"non-binary\"),\n                     state = c(\"California\", \"Pennsylvania\", \"New York\", \"Georgia\")\n                     )\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id      gender        state\n1  1        male   California\n2  2      female Pennsylvania\n3  3 transgender     New York\n4  4  non-binary      Georgia\n```\n:::\n\n```{.r .cell-code}\n# Let's change all the gender values to abbreviations.\n\ndf$gender <- gsub(\"female\", \"F\", df$gender)\ndf$gender <- gsub(\"male\", \"M\", df$gender)\ndf$gender <- gsub(\"transgender\", \"T\", df$gender)\ndf$gender <- gsub(\"non-binary\", \"NB\", df$gender)\n\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id gender        state\n1  1      M   California\n2  2      F Pennsylvania\n3  3      T     New York\n4  4     NB      Georgia\n```\n:::\n\n```{.r .cell-code}\n# Looks good. Now let's change all the state names to their abbreviations. \n\ndf$state <- gsub(\"California\", \"CA\", df$state)\ndf$state <- gsub(\"Pennsylvania\", \"PA\", df$state)\ndf$state <- gsub(\"New York\", \"NY\", df$state)\ndf$state <- gsub(\"Georgia\", \"GA\", df$state)\n\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id gender state\n1  1      M    CA\n2  2      F    PA\n3  3      T    NY\n4  4     NB    GA\n```\n:::\n\n```{.r .cell-code}\n# You can also substitute a blank space for any value with gsub()\n\ndf$state <- gsub(\"CA\", \" \", df$state)\ndf$state\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" \"  \"PA\" \"NY\" \"GA\"\n```\n:::\n:::\n\n\nWhen it comes to substituting strings, it's better to test replacement code on a smaller set of values before expanding to all the values you want to modify. This will avoid errors.\n\n## Comparisons\n\n![](/Images/comparisons.png)\n\nVery often we are interested in comparing two quantities in R. For instance, we may compare a variable to a value, or two variables to one another. We can also use Boolean operators in constructing our comparisons. Boolean operators are words like *AND*, *NOT*, and *OR* that are used as conjunctions commonly to create advanced search terms. However, we can also use them in creating comparisons.\n\n### Comparison Operators\n\nTo start, let us remind ourselves of common operators used in comparisons, as well as the three common Boolean operators, seen in @tbl-ops.\n\n| Operator (R code) | Description              |\n|-------------------|--------------------------|\n| ==                | Equals to                |\n| !=                | Not equal to             |\n| \\<                | Less than                |\n| \\>                | Greater than             |\n| \\<=               | Less than or equal to    |\n| \\>=               | Greater than or equal to |\n| !                 | NOT                      |\n| \\|                | OR                       |\n| &                 | AND                      |\n\n: Operators used for comparisons in R. {#tbl-ops}\n\nYou can use these to compare values or objects. Comparisons result in a logical value being returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comparing values\n\n12 > 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n4.32 == (16.03/4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\npi^pi <= (4 * pi) / (pi + 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Comparing objects\n\na <- 453\n\nb <- 4 * 23\n\na >= b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n## The objects being can be vectors of the same length. This will return a vector of logical values.\n\nc <- mtcars$mpg > mtcars$wt\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\n# Booleans can be used to create multiple conditions for the comparison.\n\nd <- 500\ne <- 50\n\n# This evaluates to FALSE becase d > 100.\nd < 100 & e < 100\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# This evaluates to TRUE because at least one of {d,e} < 100. \nd < 100 | e < 100\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# This evaluates to TRUE because d > e.  \n\nd != e\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Comparisons in Conditional Statements\n\nComparisons are commonly used within `if` and `if else` statements. These are conditional statements that specify a condition that must be satisfied, and then list rules for what happens if the condition is satisfied and what happens when it is not satisfied. The logic of the `if else` statement in show in @fig-ifelse.\n\n![The simple and elegant logic of the If Else statement.](/Images/ifelse.png){#fig-ifelse}\n\nLet's have a look at some simple If Else statements involving comparisons. Note that the If and Else blocks are surrounded by curly braces `{ }`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First, we create some variables.\n\nf <- 25\ng <- 50\nh <- 10\n\n# Now let's try a simple If Else statement comparing the variables.\n\nif (g < f) {                     # Here comes the If block\n  print(\"g is less than f\")\n} else {                         # Here comes the Else block\n  print(\"g is greater than f\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g is greater than f\"\n```\n:::\n\n```{.r .cell-code}\nif (g < h) {                     # Here comes the If block\n  print(\"g is less than h\")\n} else {                         # Here comes the Else block\n  print(\"g is not less than h\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g is not less than h\"\n```\n:::\n:::\n\n\nWe can also add more conditions with the `else if` statement, which basically tells R \"If the previous condition is not true, here's another condition with a rule.\" Let's add an Else If statement to the example above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First, we create some variables.\n\nf <- 25\ng <- 50\ni <- 50\n\n# Now we add some Else If statements to our IF statement.\n\nif (g < i) {\n  print(\"g is less than i\")\n} else if (g > i) {\n  print(\"g is greater than i\")\n} else if (g == i) {\n  print(\"g is equal to i\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g is equal to i\"\n```\n:::\n\n```{.r .cell-code}\n# You might say that the third Else If condition above can just be an Else statement, since if g !< i & g !> i, it must be that g == i. This is true! Let's write it that way.\n\nif (g < i) {\n  print(\"g is less than i\")\n} else if (g > i) {\n  print(\"g is greater than i\")\n} else {\n  print(\"g is equal to i\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g is equal to i\"\n```\n:::\n:::\n\n\nWe can also add the AND operator `&` and OR operator `|` to the conditional statements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's create some variables.\n\nj <- 100\nk <- 200\nl <- 150\n\n# Now we use & (AND) in our if else statement.\n\nif (j < l & j < k) {\n  print(\"j is the lowest\")\n} else if (j > l & j > k) {\n  print(\"j is the highest\")\n} else {\n  print(\"j is the middle value\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"j is the lowest\"\n```\n:::\n\n```{.r .cell-code}\n# Now we use | (OR) in our if else statement.\n\nif (l < k | l < j) {\n  print(\"l is less than at least one other value\")\n} else {\n  print(\"l is the highest\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"l is less than at least one other value\"\n```\n:::\n:::\n\n\nThat about wraps it up for Strings and Comparisons. As always, don't forget to...\n\n![](/Images/manx2.png)\n\n## Exercises {#sec-sboex}\n\nAs always, it's a good idea to attempt these while the material is still fresh. You can find the answers in @sec-appendixops.\n\n1.  Create a variable called `MarySue1` with the value `\"Dr Mary Sue Coleman, former president of the University of Michigan once said\"`. Then, create another variable called `MarySue2` with the value `\"For today, goodbye. For tomorrow, good luck. And Forever, Go Blue!\"`. Then find the number of characters in each variable using the `nchar()` function. Then, check if the letter 'r' is present in each variable, and report the results.\n\n2.  Create a variable called `MarySue3` whose value is a concatenation (combination) of `MarySue1` and `MarySue2`. Then, print the value for `MarySue3`.\n\n3.  Create a string vector called `basho` and assign it the value `\"An old silent pond. A frog jumps into the pond—Splash! Silence again.\"` Then create and print another variable called `basho2` in which the word 'frog' has been replaced by 'buffalo', and the word 'Splash!' has been replaced by 'Yikes!'.\n\n4.  Let's do a variation of Mad Libs I will call Mad Sentences. Install and load the `keyToEnglish` package (be mindful of the capitalization in this package's name). Then create three variables named after your three favorite cuisines. For each variable, assign the value `generate_random_sentences(n = 2, punctuate = TRUE)` to generate two random sentences per variable. This will produce a total of six sentences (two per variable). Finally, create a variable called `madsentences` whose value combines (pastes) all three variables. Print `madsentences`. If it sounds nonsensical, then it worked!\n\n5.  Let's compare the returns from simple vs compound interest after five years. First, define `p` as `1000`, `r` as `.07` and `t` as 5. Then Create a variable called `simple` with the value `p * r * t`. Next, create a variable `compound` with the value `p * (1 + r)^t - p`. Then, perform a logical test to see if `simple` is equal to `compound`, and write out the results of the test in one sentence.\n\n6.  Retain the variables you created above and write a series of conditional (If else/Else If) statements according to the following rules: 1) If `simple` is less than `compound`, print the statement \"Simple interest is less than compound interest\"; 2) If `simple` is greater `compound`, print the statement \"Simple interest is greater than compound interest\"; 3) If `simple` is equal to `compound`, print the statement \"Simple interest is equal to compound interest\".\n",
    "supporting": [
      "stringscomps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}