{
  "hash": "85432297d27d407e4c16f9c86a957256",
  "result": {
    "markdown": "# Answers for @sec-sboex {#sec-appendixops}\n\n1.  Create a variable called `MarySue1` with the value `\"Dr Mary Sue Coleman, former president of the University of Michigan once said\"`. Then, create another variable called `MarySue2` with the value `\"For today, goodbye. For tomorrow, good luck. And Forever, Go Blue!\"`. Then find the number of characters in each variable using the `nchar()` function. Then, check if the letter 'r' is present in each variable, and report the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMarySue1 <- \"Dr Mary Sue Coleman, former president of the University of Michigan once said\"\n\nMarySue2 <- \"For today, goodbye. For tomorrow, good luck. And Forever, Go Blue!\"\n\nnchar(MarySue1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 77\n```\n:::\n\n```{.r .cell-code}\nnchar(MarySue2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 66\n```\n:::\n\n```{.r .cell-code}\n# There are 77 characters in MarySue1 and 66 characters in MarySue2.\n\n\ngrepl('r', MarySue1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ngrepl('r', MarySue2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# The letter r is present in both variables MarySue1 and MarySue2.\n```\n:::\n\n\n2.  Create a variable called `MarySue3` whose value is a concatenation (combination) of `MarySue1` and `MarySue2`. Then, print the value for `MarySue3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMarySue3 <- paste(MarySue1, MarySue2)\nprint(MarySue3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Dr Mary Sue Coleman, former president of the University of Michigan once said For today, goodbye. For tomorrow, good luck. And Forever, Go Blue!\"\n```\n:::\n:::\n\n\n3.  Create a string vector called `basho` and assign it the value `\"An old silent pond. A frog jumps into the pond—Splash! Silence again.\"` Then create and print another variable called `basho2` in which the word 'frog' has been replaced by 'buffalo', and the word 'Splash!' has been replaced by 'Yikes!'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasho <- \"An old silent pond. A frog jumps into the pond—Splash! Silence again.\"\n\nbasho2 <- basho\n\ngsub('frog', 'buffalo', basho2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"An old silent pond. A buffalo jumps into the pond—Splash! Silence again.\"\n```\n:::\n\n```{.r .cell-code}\ngsub('Splash!', 'Yikes!', basho2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"An old silent pond. A frog jumps into the pond—Yikes! Silence again.\"\n```\n:::\n\n```{.r .cell-code}\nprint(basho2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"An old silent pond. A frog jumps into the pond—Splash! Silence again.\"\n```\n:::\n:::\n\n\n4.  Let's do a variation of Mad Libs I will call Mad Sentences. Install and load the `keyToEnglish` package (be mindful of the capitalization in this package's name). Then create three variables named after your three favorite cuisines. For each variable, assign the value `generate_random_sentences(n = 2, punctuate = TRUE)` to generate two random sentences per variable. This will produce a total of six sentences (two per variable). Finally, create a variable called `madsentences` whose value combines (pastes) all three variables. Print `madsentences`. If it sounds nonsensical, then it worked!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keyToEnglish)\n\nindian <- generate_random_sentences(n = 2, punctuate = TRUE)\nchinese <- generate_random_sentences(n = 2, punctuate = TRUE)\nkorean <- generate_random_sentences(n = 2, punctuate = TRUE)\n\nmadsentence <- paste(indian, chinese, korean)\nprint(madsentence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ephemeral thorny rivet invests bronze thespians. Nautical bumpy pork classifies tiny mezzanines. Vain shaggy astronaut scorches tweedy hobgoblins.\"            \n[2] \"Mercurial camoflauged kitchen perturbs metallic cakes. Rare irridescent barterer dries bipedal novels. Offbeat electrum limburger overloads miniscule sponges.\"\n```\n:::\n:::\n\n\n5.  Let's compare the returns from simple vs compound interest after five years. First, define `p` as `1000`, `r` as `.07` and `t` as 5. Then Create a variable called `simple` with the value `p * r * t`. Next, create a variable `compound` with the value `p * (1 + r)^t - p`. Then, perform a logical test to see if `simple` is equal to `compound`, and write out the results of the test in one sentence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- 1000\nr <- 7 / 100\nt <- 5\n\nsimple <- p * r * t\n\ncompound <- p * (1 + r)^t - p\n\nsimple == compound\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Simple interest is not equal to compound interest in five years at a principal of 1000 (dollars) and a rate of seven percent.\n```\n:::\n\n\n6.  Retain the variables you created above and write a series of conditional (If else/Else If) statements according to the following rules: 1) If `simple` is less than `compound`, print the statement \"Simple interest is less than compound interest.\"; 2) If `simple` is greater `compound`, print the statement \"Simple interest is greater than compound interest.\"; 3) If `simple` is equal to `compound`, print the statement \"Simple interest is equal to compound interest.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (simple < compound) {\n  print(\"Simple interest is less than compound interest\")\n} else if (simple > compound) {\n  print(\"Simple interest is greater than compound interest\")\n} else {                             # could also be else if (simple == compound)\n  print(\"Simple interest is equal to compound interest\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Simple interest is less than compound interest\"\n```\n:::\n:::\n",
    "supporting": [
      "appstringcomp_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}